#------------------------------------------------------------------------------------------------------------------
# WORKLOAD GENERATOR CONFIG FILE
# This is a configuration file for a simple SWF-based and AleaNG-compatible workload generator
# It will create correct: 
#  1) job file (in extended SWF format, see SWF description: https://www.cs.huji.ac.il/labs/parallel/workload/swf.html) 
#  2) machine file (describe clusters)
#  3) queue file (describe queues and their limits and priorities)
#  4) group file (describe user-groups and their limits)
#  5) user file (describe users, their groups, their relative shares and limits)
#------------------------------------------------------------------------------------------------------------------

# DATA_SET name (output workload name)
workload_filename=Example8-5days-exclusive_100%.swf

# DATA_SET directory (output directory name)
workload_dir=generated_workloads

# NUMBER of ACTIVE DAYS: how many days the users submit their jobs
days=5
 
# SYSTEM LOAD: target system load, e.g., 0.8 means that the generator will create workload that occupies ~80% of all CPU resources (ideally packed)
# useful to influence the "backlog" of waiting jobs (1.5 -> huge, 0.99 -> large, 0.6 -> small)
system_load=0.9

# Number of random unique workloads that will be created using this setup
workload_instances=1

# URGENT JOBS: how many jobs (in %) will belong to urgent QoS (urgent QoS jobs have higher priority). 
load_percentage_urgent=5


# USERS (comma separated list): two classes are supported (urgent and normal)
# format: user_name <TAB> shares(int) <TAB> CPU_limit_quota(int)
# keywords for job size: [tiny, large, small] - used by generator to identify job size   
# keywords for user priority (QoS) group: [urgent, normal] - used by generator to identify job priority class 
user_names_urgent=urgent_tiny_U1 \t 2 \t 1053696
user_names_normal=normal_large_U1 \t 1 \t 1053696,normal_small_U1 \t 1 \t 1053696,normal_small_U2 \t 1 \t 1053696,normal_small_U3 \t 1 \t 1053696,normal_tiny_U1 \t 1 \t 1053696,normal_tiny_U2 \t 1 \t 1053696

# How user CPU time is distributed among users (relative sizes)
# Since there is only one urgent user ("urgent_tiny_U1..."), he or she will receive all the CPU time allocated for urgent jobs (i.e., 100% of those 5% of overal CPU time - see: "load_percentage_urgent=5")
urgent_users_job_ratios=1
# Normal users wil have their overal CPU time divided in the ratio of 8 : 7 : 6 : 5 : 4 : 31 (the position corresponds to "user_names_normal=..." ordering above)
normal_users_job_ratios=8,7,6,5,4,31

# GROUPS (comma separated list): two groups are supported in this generator (priority and normal). Priority (urgent) group must come first (need to have id==0)
# format: group_name <TAB> shares(int) <TAB> CPU_limit_quota(int)
group_names=priority_group \t 2 \t 1053696,normal_group \t 1 \t 1053696

# QUEUES (comma separated list): specification of queues, their limits and queue priorities (used to determine which queue to traverse first, second, etc.)
# Priority (urgent) queue must come first (need to have id==0)
# format: queue_name <TAB> CPU_limit_quota(int) <TAB> priority(int)
queue_names=priority_queue \t 1053696 \t 50,default_queue \t 1053696 \t 20

# CLUSTERS (comma separated list): specification of the clusters. Cluster "property" String can be used to steer jobs to suitable clusters.  
# format: cluster_name <TAB> #of nodes(int) <TAB> CPUs per node(int) <TAB> processing_speed(int) <TAB> RAM(GB)(int) <TAB> property (String) <TAB> #of GPUs(int)
machine_names = cl_normal \t 9408 \t 112 \t 1 \t 256 \t normal \t 4
# the total number of CPUs in the system
total_cpus = 1053696

# the number of CPUs on the largest node
largest_node_cpus = 112

# FULL NODE JOBS [true/false] - decides whether ALL jobs allocate whole nodes or not (false => space-sharing can appear as multiple jobs may run on the same node)
# If true, all jobs occupy whole nodes, and #of CPU cores translates to number of allocated nodes. Also, clusters ("machine_names=..." above) should be specified as having N nodes, each having 1 CPU (to speed up simulation) 
all_jobs_allocate_whole_nodes = false

# SOME jobs require exclusive use of nodes [true/false]. Next, percentage of such jobs.
# Job will still require N nodes x M CPU cores, but will receive property "excl" so AleaNG will make sure to allocate whole N nodes exclusively (that have at least M CPU cores) 
allow_exclusive_jobs = true

# percentage of exclusive jobs (how many % of jobs will require nodes exclusively)
exclusive_percentage = 100

# NUMBER of NODES to be ALLOCATED by one JOB (will be selected randomly from this interval)
number_of_nodes_for_job = 3, 3, 3, 3, 3, 3, 128, 128, 128, 128, 150, 150, 192, 256, 256, 512, 2048, 2048, 2048, 4096, 9261, 9408

# BATCH SIZE: how many jobs are submitted within one batch (batch = jobs submitted at once at a given time by a given user). 
# User-to-batch size matching is done using the keywords [tiny, large, small] in user names. 
# The smaller the jobs is (small, tiny) the higher the number of jobs.
batch_size_large=1
batch_size_small=2
batch_size_tiny=3

# JOB CPU requirements (comma separated list): actual values are chosen randomly from these lists of eligible CPU requirements 
# User-to-job size matching is done using the keywords [tiny, large, small] in user names. 
# (tiny & small => used for tiny & small users; large => used for large users)
tiny_job_sizes = 16, 56, 56, 64, 112, 112
small_job_sizes = 112
large_job_sizes = 112

# JOB WALLTIME (comma separated list): eligible walltime limits (actual job runtimes are randomly generated to be smaller)
job_runtime_limit = 300, 600, 900, 1200, 1800, 2400, 3600, 6000, 6000, 6000, 7200, 7200, 7200, 9600, 10200, 12000, 14400, 43200

# INTER BATCH IDLE TIME (comma separated list): how many seconds pass between two different batches.
# Different eligible interarrival times are used for urgent and normal jobs, respectively using the keywords [normal, urgent] in user names. 
# Interarrival times are prolonged (more spread out) when desired system load is lower: (inter_batch_idle_period * (1.0 / system_load)).
inter_batch_idle_period_urgent = 1800, 3600, 5400, 7200
inter_batch_idle_period_normal = 300, 600, 900, 1200, 1500, 1800, 2100, 2400, 2700, 3600

